---
title: 图相关算法
date: 2017-11-12 20:05:00
tags: [leetcode,graph]
---

## 图的遍历 or 复制

### 问题描述

给出一个无向图的一个节点，返回克隆后的图。

### 解决思路

在基础的一些算法上，图可以参考树的一些算法，比如深度优先遍历、广度优先遍历等。不同之处在于树不会有圈和环，而图可能会有。因此我们需要使用一个Map类似的结构对已经经历过的结点进行记录，防止无限循环。

同样的，我们可以采用深度优先和广度优先两种方式进行图的构造。

深度优先遍历算法如下：

```python
# Definition for a undirected graph node
# class UndirectedGraphNode:
#     def __init__(self, x):
#         self.label = x
#         self.neighbors = []

class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    mapper = {}
    def cloneGraph(self, node):
        if node is None:
            return None
        if node in self.mapper:
            return self.mapper[node]

        self.mapper[node] = UndirectedGraphNode(node.label)
        for item in node.neighbors:
            self.mapper[node].neighbors.append(self.cloneGraph(item))
        return self.mapper[node]
```

广度优先遍历算法如下，和树的广度优先遍历类似，这里借助队列实现：

```python
# Definition for a undirected graph node
class UndirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []

class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    mapper = {}
    def cloneGraphByBFS(self, node):
        if node is None:
            return None
        head = UndirectedGraphNode(node.label)
        self.mapper[node] = head
        queue = [ node ]
        while len(queue) != 0:
            tmp = queue[0]
            queue = queue[1:]
            for item in tmp.neighbors:
                if item not in self.mapper:
                    self.mapper[item] = UndirectedGraphNode(item.label)
                    queue.append(item)
                self.mapper[tmp].neighbors.append(self.mapper[item])
        
        return head
```



相关题目： Leetcode 133
