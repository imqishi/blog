---
title: Single Number问题
date: 2017-11-17 23:16:00
tags: [leetcode,bitop]
---


### 问题描述

总的来说，这类问题可以用下述语句进行表达：

一堆数字，除了有一个数字出现了M次以外，其他所有的数字都出现了K次。求这个数字是多少。

### 问题分析

首先可以确定的是，这类问题可以用**O(n)时间复杂度**，**不借助（或者说只需要常数级的）额外空间**，利用**位运算**完成。接下来我们一步一步分析如何做。

1. 假设我们没有上面额外空间的要求，那么对于一个整数（假设考虑int类型）是32位，因此我们可以**使用一个长度为32的数组**记录**每个位为1的次数**。那么到最后我们看看数组中哪个位置 **模M** 不是0，**把这些不是0的位记录下来然后组成一个二进制01串，这个串所代表的十进制数字即为所求**。
2. 现在我们要考虑空间的开销，所以需要利用位运算。因此我们要构造一个方法，用二进制去实现M进制。接下来以 M=3 为例进行构造进制转换。

我们知道用两个位就可以表示3种状态，因此我们用 a, b 进行计数，用 c 表示下一个到来的位。可以得到下面的转换图，或者说是二进制到三进制的转换规则：

```
current   incoming  next
a b            c    a b
0 0            0    0 0
0 1            0    0 1
1 0            0    1 0
0 0            1    0 1
0 1            1    1 0
1 0            1    0 0
```

这张图怎么理解呢？反正我一开始是没看懂的，原因是没有了解用二进制去构造三进制的这么一个思想。这里再解释一下：

当前状态是00，下一个到来的是0，那么得到的还是00。因为只有1的时候才需要被计数…

当前状态是01，下一个如果到来的是0，那么不变，原因同上。如果是1，那么 01 + 1 = 10。

当前状态是10，下一个如果到来的是0，不变。如果是1，那么 10 + 1 = 11。而我们现在要构造三进制，11是不存在的（一个状态），应该回到0。

因此，我们把除了 11 以外的状态的转移规则全部列出如上。

**然后，题目的Discuss就直接根据自动机之类的知识（让我们自己无限脑补）推出了一个 a 和 b 的表达式，对于形式语言与自动机忘了好几年的人来说真是费劲...看了好几个其他人的评论以后，总算总结出了为什么得到 a 和 b 的那俩表达式：**

首先我们知道，我们在构造三进制，我们用 a 和 b 计数，**只有当 a 和 b 都为0的时候，这个位置才是合法的（结合分析1，只有%3为0的才是正好出现3次的）**。因此，我们**只需要考虑的是 next 中的 a 为 1 或者 b 为 1 的情况**。

以 a 为例，我们可以看到，next中 a 为 1 的时候只有下面两种情况：

```
current   incoming    next
  a b         c       a b
  1 0         0       1 0
  0 1         1       1 0
```

所以要让 next 的 a 为 1 ，需要构造的条件是：

1. a = 1, b = 0, c = 0的情况，此时只需 a = a & ~b & ~c
2. a = 0, b = 1, c = 1的情况，此时只需 a = ~a & b & c

因此我们把这两种情况综合起来就是：

a = a & ~b & ~c + ~a & b & c

同理可以获得：

b= ~a & b & ~c + ~a & ~b & c

最后，因为我们要找的是除了出现三次外的那个数是啥，可能是一次，也可能是两次，也就是 a 为 1 或者 b 为 1 的情况都可能。所以最后返回 a | b。

上面的我们是把 c 只作为一个位去看的，对于题目来说，一个 int 一般是一个32位的数字，相当于对这个32位数的每个位都进行上述运算。此方法只需要两个同类型（如int）变量 a 和 b 还有一个临时变量 ta就足够了。不需要申请一个32位的int数组。

同样的道理，分析4次，5次...M次的问题都可以用该思路解决。

### 代码

```python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        a = b = 0
        for num in nums:
            ta = ( ~a & b & num ) | ( a & ~b & ~num )
            b=( ~a & ~b & num ) | ( ~a & b & ~num )
            a=ta

        return a | b
```

