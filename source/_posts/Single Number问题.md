---
title: Single Number问题
date: 2018-01-25 23:16:00
tags: [leetcode,bitop]
---

### 问题描述

总的来说，这类问题可以用下述语句进行表达：

一堆数字，除了有一个数字出现了M次以外，其他所有的数字都出现了K次。求这个数字是多少。

### 问题分析

首先可以确定的是，这类问题可以用**O(n)时间复杂度**，**不借助（或者说只需要常数级的）额外空间**，利用**位运算**完成。接下来我们一步一步分析如何做。

1. 假设我们没有上面额外空间的要求，那么对于一个整数（假设考虑int类型）是32位，因此我们可以**使用一个长度为32的数组**记录**每个位为1的次数**。那么到最后我们看看数组中哪个位置 **模M** 不是0，**把这些不是0的位记录下来然后组成一个二进制01串，这个串所代表的十进制数字即为所求**。
2. 现在我们要考虑空间的开销，所以需要利用位运算。因此我们要构造一个方法，用二进制去实现M进制。接下来以 M=3 为例进行构造进制转换。

我们知道用两个位就可以表示3种状态，因此我们用 a, b 进行计数，用 c 表示下一个到来的位。可以得到下面的转换图，或者说是二进制到三进制的转换规则：

```
current   incoming  next
a b            c    a b
0 0            0    0 0
0 1            0    0 1
1 0            0    1 0
0 0            1    0 1
0 1            1    1 0
1 0            1    0 0
```

这张图怎么理解呢？反正我一开始是没看懂的，原因是没有了解用二进制去构造三进制的这么一个思想。这里再解释一下：

当前状态是00，下一个到来的是0，那么得到的还是00。因为只有1的时候才需要被计数…

当前状态是01，下一个如果到来的是0，那么不变，原因同上。如果是1，那么 01 + 1 = 10。

当前状态是10，下一个如果到来的是0，不变。如果是1，那么 10 + 1 = 11。而我们现在要构造三进制，11是不存在的（一个状态），应该回到0。

因此，我们把除了 11 以外的状态的转移规则全部列出如上。

**然后，题目的Discuss就直接根据自动机之类的知识（让我们自己无限脑补）推出了一个 a 和 b 的表达式，对于形式语言与自动机忘了好几年的人来说真是费劲...看了好几个其他人的评论以后，总算总结出了为什么得到 a 和 b 的那俩表达式：**

首先我们知道，我们在构造三进制，我们用 a 和 b 计数，**只有当 a 和 b 都为0的时候，这个位置才是合法的（结合分析1，只有%3为0的才是正好出现3次的）**。因此，我们**只需要考虑的是 next 中的 a 为 1 或者 b 为 1 的情况**。

以 a 为例，我们可以看到，next中 a 为 1 的时候只有下面两种情况：

```
current   incoming    next
  a b         c       a b
  1 0         0       1 0
  0 1         1       1 0
```

所以要让 next 的 a 为 1 ，需要构造的条件是：

1. a = 1, b = 0, c = 0的情况，此时只需 a = a & ~b & ~c
2. a = 0, b = 1, c = 1的情况，此时只需 a = ~a & b & c

因此我们把这两种情况综合起来就是：

a = a & ~b & ~c + ~a & b & c

同理可以获得：

b= ~a & b & ~c + ~a & ~b & c

最后，因为我们要找的是除了出现三次外的那个数是啥，可能是一次，也可能是两次，也就是 a 为 1 或者 b 为 1 的情况都可能。所以最后返回 a | b。

上面的我们是把 c 只作为一个位去看的，对于题目来说，一个 int 一般是一个32位的数字，相当于对这个32位数的每个位都进行上述运算。此方法只需要两个同类型（如int）变量 a 和 b 还有一个临时变量 ta就足够了。不需要申请一个32位的int数组。

同样的道理，分析4次，5次...M次的问题都可以用该思路解决。

### 代码

```python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        a = b = 0
        for num in nums:
            ta = ( ~a & b & num ) | ( a & ~b & ~num )
            b=( ~a & ~b & num ) | ( ~a & b & ~num )
            a=ta

        return a | b
```

### 题目变形-Leetcode 260

一个数组中除了两个数字只出现一次外其他都出现两次，求这两个数字，要求时间复杂度 O(n) 空间复杂度 O(1)

分析：首先可以想到的是，将这些数字进行异或，可以得到两个出现一次数字的异或结果的值diff。下面要考虑的就是如何把这两个数字找出来。

我们知道，两个数字如果不同，异或的结果（位序列）至少有一位是1。因此我们只要这两个数字中的一个有一位的异或结果与第一轮所获得的 diff 有一位异或结果为0，另一个数字同一位置与 diff 的异或结果为1，就可以找到这两个数。因为0异或任何数都是不会改变原数字的，所以我们应该找一个为1的位进行区分。（当然也可以是多位，但是注意不能是diff的原始值，那样的话异或后结果相同就无法区分了。为了方便，我们只需要找一位不同的即可）

为了让这个“寻找一个区分两个数字的位”的操作更快，我们利用负数在计算机中以补码存储这一特点，使用 diff &= -diff 快速地获得一位让两个数字得以区分的 diff。

最终代码如下：

```python
class Solution(object):
    def singleNumberByBinaryOp(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        diff = 0
        for n in nums:
            diff ^= n
        diff &= -diff
        
        ret = [0, 0]
        for n in nums:
            if n & diff == 0:
                ret[0] ^= n
            else:
                ret[1] ^= n
        
        return ret
```

