---
title: 数学/数字类问题汇总
date: 2018-04-27 18:51:00
tags: [leetcode]
---

# Leetcode 319 Bulb Switcher

给一个n表示有n个灯泡，开始它们是全部关闭的，之后会分别以每隔0-n-1个的次序把灯泡状态取反，求最后有几个灯泡开着。比如，每隔0个把灯泡状态取反，就是全开着，每隔1个把灯泡状态取反，就是0 2 4 6 …关闭，其他的开启。

```
Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
```

首先观察题目给的例子，多写几个可以发现，**一个开关i被拨动的次数就是i的约数的个数**，比如第8个开关，它被拨动了4次，分别在轮数为1, 2, 4, 8时，而1, 2, 4, 8就是8的约数。 
所以题目就变成了求1-n中每个数i的约数个数，统计约数个数是奇数的数目，因为如果约数个数是奇数，则开关是开的。 
那么下一步就是求i的约数个数，我们注意到，**约数是成对存在的**，即2是8的约数，那么8÷2=4也是8的约数，其中有一种特殊情况，就是i为完全平方数，比如9跟它的约数3，因此， 
**如果i是完全平方数，那么i的约数个数肯定是奇数，如果i不是完全平方数，由于约数成对出现，所以约数个数肯定是偶数。** 
于是题目转化为：**计算1-n中完全平方数的数目**

而**小于等于n的平方数的数目就是直接对n的平方根取整数**，所以直接返回对n的平方根的取整即可。

# Leetcode 357 Count Numbers with Unique Digits

给出一个非负整数n，计算 0 <= i < 10^n 所有位都不同的数字有多少个。

这其实是一个排列组合问题。

首先我们考虑一位数，可以有0 - 9共10个

然后考虑2位数，第一位数字可以取 1 - 9 共9个，对于第一位已经确定的数字，第二位保证与其不同有9个可能，所以一共是9 * 9 = 81个

然后考虑3位数，同样的方法得到前两位的取值，此时还剩下8个数字可以选，所以是 9 * 9 * 8 个

4位数：9 * 9 * 8 * 7

以此类推…注意到，当位数多于10以后必然会出现重的数字，因此只需计算到10位即可

显然我们要求和就是把上述各种位数的结果加起来。易得代码如下：

```java
public int countNumbersWithUniqueDigits(int n) {
    if (n == 0) {
        return 1;
    }
    int sum = 10, last = 9;
    for (int i = 2; i <= n && i <= 10; i ++) {
        last = last * (9 - i + 2);
        sum += last;
    }

    return sum;
}
```

# Leetcode 365 Water and Jug Problem

给两个桶，分别指定他们的容量为 x 和 y。有无限量的水，判断是否能用这两个桶量出 z 数量的水。

离散数学里面讨论过的问题，其实是一个数论的问题，和分金条问题类似。

## 裴蜀定理 - 摘自Wikipedia

在数论中，裴蜀等式（英语：Bézout's identity）或裴蜀定理（Bézout's lemma）是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数  a、 b和  m，关于未知数 x 和 y的线性丢番图方程（称为裴蜀等式）：

ax + by = m

有整数解时当且仅当m是 a 及 b 的最大公约数 d 的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解 x、 y都称为裴蜀数，可用扩展欧几里得算法求得。

特别来说，方程 ax + by = 1 有整数解当且仅当整数a和b互素。

## 思路

只需要简单的求出 x 与 y 的最大公约数，然后判断 z 是否是最大公约数的倍数即可。例如：

```
x = 4, y = 6, z = 8.
GCD(4, 6) = 2
8 是 2 的倍数，并且我们可以凑出：
-1 * 4 + 6 * 2 = 8
这种情况的意思是，可以通过倒一次4升桶，向6升桶两次注入水得到所求。过程如下：先把6升桶倒满，然后把6升桶的水倒入4升桶，把4升桶清空，把剩下的2升倒入4升桶，再把6升桶注满，就得到了8升水。
其实我们可以发现，完全可以：
2 * 4 + 6 * 0 = 8
向4升桶注满水，然后倒入6升桶，再把4升桶倒满，就得到了8升。
```

## 代码

```java
public boolean canMeasureWater(int x, int y, int z) {
    if (x + y < z) {
        return false;
    }

    if (x == z || y == z || x + y == z) {
        return true;
    }

    return z % GCD(x, y) == 0;
}

public int GCD(int a, int b) {
    while (b != 0) {
        int t = a % b;
        a = b;
        b = t;
    }
    return a;
}
```

顺便复习一下求最大公约数，辗转相除法~

# Leetcode 372. Super Pow

## 题目

给出一个正整数 a 和一个正整数组成的数组 b，求 a 的 b 次方对 1337 取余的结果。

## 思路

最简单的思路就是对数组进行整数的模拟减法，然后一直减到0为止，每减1就做乘法和取余。这种方法的关键在于数组的整数减法模拟，比较常规的思路。

还有一种就是首先分析一下取余操作是个什么套路，可以发现：

```
a * b % k = ((a % k) * (b % k)) % k
```

 n 次方这个操作到底是什么样子的：

```
x^n = x^p * x^q  (n = p + q)
x^n = (x^p)^q  (n = p * q)
```

我们惊奇地发现，完全可以把以数组表示的幂数采用如上的幂操作进行分解，假设我们使用 f(a, b) 表示计算 a ^ b % 1337，有如下示例：

```
f(a, 12345) = f(f(a, 1234), 10) * f(a, 5) % 1337
```

正好符合递归函数的定义有木有！然后就可以欢乐的写代码啦

```java
final int BASE = 1337;
public int superPower(int a, int[] b) {
    LinkedList<Integer> bList = new LinkedList<>();
    for (int i : b) {
        bList.add(i);
    }
    return subSuperPower(a, bList);
}

public int subSuperPower(int a, LinkedList<Integer> b) {
    if (b.size() == 0) {
        return 1;
    }
    int last_digit = b.removeLast();

    return powMod(subSuperPower(a, b), 10) * powMod(a, last_digit) % BASE;
}

public int powMod(int a, int k) {
    a %= BASE;
    int res = 1;
    for (int i = 0; i < k; i ++) {
        res = (res * a) % BASE;
    }

    return res;
}
```

# Leetcode 371. Sum of Two Integers

## 题目

不使用 + 和 - 实现两个数字的求和操作。

## 思路

不让用符号，就是考你位运算…（这脑回路应该没啥问题

相加的操作如何完成呢？我们把数字转成二进制看，显然取与操作可以求得进位，取异或操作可以求得加和后该位应该的取值。那么我们通过一次 & 操作可以取得两个数字会发生进位的位置，通过 ^ 操作进行一次不考虑进位的加和，最终把 b 改为进位的数字左移一位（因为下一轮求和时进的位是和左边一位加，所以要左移一位）

```java
public int getSum(int a, int b) {
    while(b != 0) {
        int carry = a & b;
        a = a ^ b;
        b = carry << 1;            
    }
    return a;        
}
```

# Leetcode 172 Factorial Trailing Zeroes

给一个整数n，求 n! 中尾部有多少个0。如：

```
5! = 1 * 2 * 3 * 4 * 5 = 120
So you return 1
```

本题思路与上题类似，都是递归的思想。通过规律总结可以发现，如果末尾是0，只有 2 * 5 这种情况。对于25我们可以拆成 5 * 5，125可以拆成 5 * 5 * 5。对于 n! 来说，可以发现2的数量必然比5出现的次数多。因此我们只需要计算5出现的次数。可得代码如下：

```python
class Solution(object):
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)

obj = Solution()
print obj.trailingZeroes(5)
```

# 其他

{% post_link Leetcode 368. Largest Divisible Subset %}

{% post_link 素数问题 %}

