---
title: 字符串问题总结
date: 2018-05-06 15:07:00
tags: [leetcode,string]
---

# 求字符串中最长连续不重复字符子串长度

利用Hash数据结构，可以实现O(n)时间复杂度的算法。下面分别给出使用HashSet和HashMap的两种方式。如果要求具体的子串，只需增加一个起始和结束下标的记录即可。

基本思想就是利用一个Hash结构存储当前已经走过的字符，当一个新的字符出现时进行如下检查：如果该字符不曾存在，则尝试扩展最长子串长度；否则进行下标更新。针对不同数据结构进行如下实现：

## HashSet

使用两个游标 i j 分别指示子串的开始和结束，我们用类似于滑动窗口的方式向右滚动。当字符不存在，尝试更新最长子串长度并将 j 右移，否则将 i 右移直到 j 处已经存在于 HashSet 中的元素被移除，说明可以进行一个新的子串的扩展尝试。

```java
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    Set<Character> set = new HashSet<>();
    int res = 0, i = 0, j = 0;
    while (i < n && j < n) {
        if (! set.contains(s.charAt(j))) {
            set.add(s.charAt(j));
            j ++;
            res = Math.max(res, j - i);
        } else {
            set.remove(s.charAt(i));
            i ++;
        }
    }

    return res;
}
```

## HashMap

HashMap也是利用 i j 来进行子串范围标记，不同的是HashMap直接记录了对应元素所在的位置，当新的字符加入时，直接进行对最大长度的扩展；如果是已经存在的字符，直接把开始位置 i 更新为更靠右的那个，减少了一步一步向右移动的过程。

```java
public int lengthOfLongestSubstring2(String s) {
    int n = s.length(), res = 0;
    Map<Character, Integer> map = new HashMap<>();
    for (int j = 0, i = 0; j < n; j ++) {
        if (map.containsKey(s.charAt(j))) {
            i = Math.max(map.get(s.charAt(j)), i);
        }

        res = Math.max(res, j - i + 1);
        map.put(s.charAt(j), j + 1);
    }

    return res;
}
```

# 最长递增子序列

{% post_link 最长递增子序列问题 %}

# 回文串问题

{% post_link 5.最长回文子串 %}

