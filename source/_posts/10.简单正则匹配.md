---
title: 简单正则匹配（.和*）
date: 2017-05-25 23:30:48
tags: leetcode
---


# LeetCode 10

## 问题

给定一个字符串s和一个正则表达式p，检查是否匹配

## 方法一 - 递归遍历

我们知道，‘.’ 代表任意一个字符，而 ‘*’ 代表前面的字符出现0或多次。题目这里考虑的正则表达式p默认是正确的，不会出现一些奇怪的错误匹配式。所以我们可以每次看p中的两个字符，如果第二个是 ’\*‘ 则进行相应处理，如果不是则继续向后处理。显然这里就出现了递归，遍历所有情况，即可获得答案。但是要注意如果正则表达式是空串，那么它只匹配空。

让我们进一步讨论 p[1] 是否为 ’\*' 的情况：

1. 是。此时一种情况是p[0]没有出现过，则继续用s原串继续向后匹配即可：`isMatch(s, p[2:])` 第二种情况是p[0]出现了一次或多次，则应保证s长度大于0即 `len(s) != 0` 且 `s[0] == p[0]` 或 `p[0] == '.'` 此时可以把s的下标+1继续向后匹配 `isMatch(s[1:], p)`
2. 否。此时应保证s长度大于0并判断是否匹配，若匹配则s和p的下标均+1继续向后匹配即可

综上，递归算法如下：

```python
class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        if len(p) == 0:
            return len(s) == 0

        if p[1] == '*':
            return (self.isMatch(s, p[2:]) or len(s) != 0 and (s[0] == p[0] or '.' == p[0]) and self.isMatch(s[1:], p));
        else:
            return len(s) != 0 and (s[0] == p[0] or '.' == p[0]) and self.isMatch(s[1:], p[1:])
```

## 方法二 - 动态规划

##### 方法一遍历了所有的情况，显然效率比较低下，而通过简单的分析我们可以看出，该匹配前半部分进行的测试总结可以作为后半部分测试的前提继续用，所以考虑，是不是可以用动态规划来做呢？

我们知道，动态规划是用空间换时间的经典思想，通过一个数组保存之前的计算状态供进一步分析使用帮助我们避免了许多重复的计算。

想要使用动态规划算法，可以使用动态规划解决的问题通常有下面的特点：最优子结构，无后效性，重叠子问题。

其中最重要的一点就是**无后效性**，所谓无后效性，就是之前的状态和之后的状态之间没有关系，引用百度百科，“某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响”。

最优子结构的意思是，每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到。

重叠子问题就不用多说啦，空间换时间，通过记录子问题的结果用于下一步的快速计算。

之前的时候我们曾经用DP解决过最长回文子串的问题，是以回文串的长度作为一个基准去不断扩张计算（长度更长的串必然包括长度短的，因此由短推长）。

这里我们设置一个数组 f\[i][j] 表示 s[0 ~ i-1] 和 p[0 ~ j-1] 相匹配。

##### 对初始条件进行以下分析：

1. 空串除了和空正则表达式相匹配，其他情况下均不能匹配，故 f\[0][0] = True, i >0时 f\[i][0] = False
2. 当正则表达式中遇到 '*' 时（p\[j-1] = '\*'）需要考虑前一位的情况，只有当 f\[0][j-2] = True 且 j > 1时为 f\[0][j] True

##### 对于 f\[i][j] ：

1. 如果p[j-1] != '\*' 只需 f\[i-1][j-1] = True(前面的都匹配) 且 (s[i] = p\[j] 或 p[j-1] = '.') 即为True

2. 如果p[j-1] = '*' 若令 f\[i][j] = True 此时又有下面几种情况，其中一种成立即可为True：

   a. 如果s中没有出现匹配串，那么只需 f\[i][j-2] = True。这个比较好理解，就是 s\[0 ~ i-1] 和 p[0 ~ j-3] 匹配即可（p[j-2]和p[j-1]分别是一个任意字符和 '*' 字符，没有匹配到）

   b. 如果出现了至少一次，那么 f\[i-1][j] = True 且 (s[i-1] = p\[j-2] 或 p[j-2] = '.') 

   ​	因为出现了至少一次，所以是s[0 ~ i-2]和p[0 ~ j-1]匹配成功，故要有f\[i-1][j] = True

   ​	要继续匹配下去，那么要看p[j-2]的关系（p[j-1]是 ‘*’）

综上，代码如下：

```python
class Solution(object):
    def isMatch(self, s, p):
        m = len(s)
        n = len(p)
        f = [[False for i in range(n + 1)] for i in range(m + 1)]
        f[0][0] = True
        i = 1
        while i <= m:
            f[i][0] = False
            i += 1

        j = 1
        while j <= n:
            f[0][j] = j > 1 and '*' == p[j-1] and f[0][j-2]
            j += 1

        i = 1
        while i <= m:
            j = 1
            while j <= n:
                if p[j-1] != '*':
                    f[i][j] = f[i-1][j-1] and (s[i-1] == p[j-1] or '.' == p[j-1])
                else:
                    f[i][j] = f[i][j-2] or ((s[i-1] == p[j-2] or '.' == p[j-2]) and f[i-1][j])
                j += 1
            i += 1

        return f[m][n]
```

