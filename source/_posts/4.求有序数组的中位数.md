---
title: 求有序数组的中位数
date: 2017-05-04 15:01:48
tags: leetcode
---


# LeetCode 4

## 方法一

遍历，分别从两个数组头最小的开始向后走，走到中间为止。这种方法最简单，但是时间复杂度为O(m+n)，那么有没有更快的方法呢？

由题目要求我们的算法时间复杂度为O(log (m+n))可以看出显然是有的，看到log就让人想起二分，没错，这种更快的方法正是利用了二分的原理。

## 方法二

根据中位数的定义可以知道，中位数是一组数据中位于中间位置的数字，这也就意味着，假设有两个有序数组A和B：

把A分成两部分，分别为0 ~ i-1, i ~ m-1

把B分成两部分，分别为0 ~ j-1, j ~ n-1

可以知道

i-1-0+1 + j-1-0+1 = m-1-i+1 + n-1-j+1

也就是 i + j = (m + n) / 2

这里要注意的是，该式是m+n为偶数时成立的情况，当m+n为奇数时，i+j = (m+n+1) / 2，原因如下：

###  首先我们要搞清楚，按这种分法，中位数在哪里产生：

1. 如果是偶数的话，显然应该是i-1和j-1的较大者与i和j的较小者的均值
2. 如果是奇数的话，则我们认定为i-1和j-1的较大者

### 在这种情况下，我们进行假设：

假设A = [1,2], B = [3,4]，以第一轮为例，i = 2 / 2 = 1, j = 4 / 2 - 1 = 1，注意i和j是数组下标，也就是说，左侧分别有一个下标为0的数，正好是中位数。假设我们+1，i + j = 5 / 2 = 2 正确

假设A = [1, 2], B= [3, 4, 5]，以第一轮为例，如果不+1，i = 2 / 2 = 1, j = 5 / 2 - 1 = 1，由于i和j是数组下标，那么左侧共有两个数，而根据之前的定义左侧应该有3个数，所以只有+1以后才能满足左侧有3个数（此时j = 2）

为什么必须是3个数呢？这要从开始的解题思路说起，因为我们假设分成的两部分是以 i, j 为分割的，那么左侧加起来应该为总长度的一半，此时中位数为左侧最大与右侧最小的均值。如果无法整除，取左侧最大。所以左侧长度要么为一半，要么为一半 +1，故i + j = (m + n + 1) / 2

为什么要保证m < n呢？因为如果m > n，i比较大，有可能会出现j为负数的情况。

### 那么搜索的时候有哪些情况呢？

```
<a> (j == 0 or i == m or B[j-1] <= A[i]) and
    (i == 0 or j = n or A[i-1] <= B[j])
    i即为所求.

<b> j > 0 and i < m and B[j - 1] > A[i]
    i太小，应该增加（j会相应减小）.

<c> i > 0 and j < n and A[i - 1] > B[j]
    i太大，应该减小（j会相应增加）.
```

### 综上，代码如下：

```python
 def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    if n == 0:
        raise ValueError

    imin, imax, half_len = 0, m, (m + n + 1) / 2
    while imin <= imax:
        i = (imin + imax) / 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            # i is too small, must increase it
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            # i is too big, must decrease it
            imax = i - 1
        else:
            # i is perfect

			# i = 0意味着数组A太大了，走到左侧的头了，左侧只有B了，所以左侧的最大值应该为B[j-1]
            if i == 0: max_of_left = B[j-1]
            # j = 0意味着B太大了，指针走到左侧的头了，左侧只有A了，所以左侧最大值应该为A[i-1]
            elif j == 0: max_of_left = A[i-1]
            # 否则说明中位数的第一个数字（左侧较大的）在两组数据的中间位置
            else: max_of_left = max(A[i-1], B[j-1])

			# 根据上面的分析知道如果是奇数，该数就是中位数
            if (m + n) % 2 == 1:
                return max_of_left

			# 如果i走到最右边，说明A太小了，右侧只有B，所以右侧最小值是B[j]
            if i == m: min_of_right = B[j]
            # 如果j走到最右边，说明B太小了，右侧只有A，所以右侧最小值是A[i]
            elif j == n: min_of_right = A[i]
            # 否则说明中位数的第二个数字(右侧较小的)在两组数据的中间位置
            else: min_of_right = min(A[i], B[j])

			# 如果是偶数，应该为左侧最大与右侧最小值的均值
            return (max_of_left + min_of_right) / 2.0
```

## 小结

解题过程中遇到的问题与解决思路主要有两个：

1. 第一次尝试解题，没能把中位数的概念运用好，i和j之间的关系没有用起来，导致i与j各自独立，计算的时候混乱。
2. 第二次尝试解题，注意了i与j之间的关系，但是对于 m + n + 1 中为什么+1没搞清楚，至于为什么+1，在上面已经讲清楚了。
3. 如果说还有小的点，那就是对imin和imax的设置了，一定要注意是 i + 1或者 i - 1 ，不是设置成1...这算是二分的基本点了。
